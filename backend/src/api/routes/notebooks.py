"""API router for notebook operations."""

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from typing import List

from src.api.dependencies import get_db, get_notebook_repository
from src.api.schemas import NotebookCreate, NotebookUpdate, NotebookResponse
from src.core.domain.notebook import Notebook
from src.infrastructure.data.repositories.notebook_repository import NotebookRepository

router = APIRouter(
    prefix="/api/notebooks",
    tags=["notebooks"],
)


@router.get("/", response_model=List[NotebookResponse])
async def list_notebooks(
    db: AsyncSession = Depends(get_db),
):
    """
    List all notebooks.
    
    Returns:
        List of notebooks with basic information.
    """
    repo = get_notebook_repository(db)
    notebooks = await repo.get_all(include_deleted=False)
    
    return [NotebookResponse(
        id=nb.id,
        name=nb.name,
        color=nb.color,
        created_at=nb.created_at,
        updated_at=nb.updated_at,
        deleted_at=nb.deleted_at
    ) for nb in notebooks]


@router.post("/", response_model=NotebookResponse, status_code=status.HTTP_201_CREATED)
async def create_notebook(
    notebook_data: NotebookCreate,
    db: AsyncSession = Depends(get_db),
):
    """
    Create a new notebook.
    
    Returns:
        Created notebook with ID.
    """
    repo = get_notebook_repository(db)
    
    # Create domain entity
    notebook = Notebook(
        id="",  # Will be generated by repository
        name=notebook_data.name.strip(),
        color=notebook_data.color,
    )
    
    # Validate
    is_valid, error_msg = notebook.validate()
    if not is_valid:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=error_msg)
    
    # Save
    created_notebook = await repo.create(notebook)
    
    return NotebookResponse(
        id=created_notebook.id,
        name=created_notebook.name,
        color=created_notebook.color,
        created_at=created_notebook.created_at,
        updated_at=created_notebook.updated_at,
        deleted_at=created_notebook.deleted_at
    )


@router.get("/{notebook_id}", response_model=NotebookResponse)
async def get_notebook(
    notebook_id: str,
    db: AsyncSession = Depends(get_db),
):
    """
    Get notebook by ID.
    
    Args:
        notebook_id: UUID of the notebook.
    
    Returns:
        Notebook details with sections.
    """
    repo = get_notebook_repository(db)
    notebook = await repo.get_by_id(notebook_id)
    
    if not notebook:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Notebook not found")
    
    return NotebookResponse(
        id=notebook.id,
        name=notebook.name,
        color=notebook.color,
        created_at=notebook.created_at,
        updated_at=notebook.updated_at,
        deleted_at=notebook.deleted_at
    )


@router.put("/{notebook_id}", response_model=NotebookResponse)
async def update_notebook(
    notebook_id: str,
    notebook_data: NotebookUpdate,
    db: AsyncSession = Depends(get_db),
):
    """
    Update notebook details.
    
    Args:
        notebook_id: UUID of the notebook.
    
    Returns:
        Updated notebook.
    """
    repo = get_notebook_repository(db)
    notebook = await repo.get_by_id(notebook_id)
    
    if not notebook:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Notebook not found")
    
    # Update fields
    if notebook_data.name is not None:
        notebook.name = notebook_data.name.strip()
    if notebook_data.color is not None:
        notebook.color = notebook_data.color
    
    # Validate
    is_valid, error_msg = notebook.validate()
    if not is_valid:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=error_msg)
    
    # Save
    updated_notebook = await repo.update(notebook)
    
    return NotebookResponse(
        id=updated_notebook.id,
        name=updated_notebook.name,
        color=updated_notebook.color,
        created_at=updated_notebook.created_at,
        updated_at=updated_notebook.updated_at,
        deleted_at=updated_notebook.deleted_at
    )


@router.delete("/{notebook_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_notebook(
    notebook_id: str,
    db: AsyncSession = Depends(get_db),
):
    """
    Soft delete a notebook.
    
    Args:
        notebook_id: UUID of the notebook.
    
    Returns:
        Success confirmation.
    """
    repo = get_notebook_repository(db)
    success = await repo.delete(notebook_id)
    
    if not success:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Notebook not found")
    
    return None

