"""API router for page operations."""

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from typing import List, Optional
import re

from src.api.dependencies import get_db, get_page_repository
from src.api.schemas import PageCreate, PageUpdate, PageResponse
from src.core.domain.page import Page

router = APIRouter(
    prefix="/api/pages",
    tags=["pages"],
)


def extract_plain_text(markdown_content: str) -> str:
    """Extract plain text from markdown for search indexing."""
    # Remove markdown formatting (simple implementation)
    text = markdown_content
    # Remove code blocks
    text = re.sub(r'```[\s\S]*?```', '', text)
    # Remove inline code
    text = re.sub(r'`[^`]*`', '', text)
    # Remove links but keep text
    text = re.sub(r'\[([^\]]+)\]\([^\)]+\)', r'\1', text)
    # Remove images
    text = re.sub(r'!\[([^\]]*)\]\([^\)]+\)', '', text)
    # Remove headers
    text = re.sub(r'^#+\s+', '', text, flags=re.MULTILINE)
    # Remove bold/italic
    text = re.sub(r'[*_]{1,2}([^*_]+)[*_]{1,2}', r'\1', text)
    return text.strip()


@router.get("/", response_model=List[PageResponse])
async def list_pages(
    section_id: Optional[str] = None,
    db: AsyncSession = Depends(get_db),
):
    """
    List pages, optionally filtered by section.
    
    Args:
        section_id: Optional section UUID to filter by.
    
    Returns:
        List of pages.
    """
    repo = get_page_repository(db)
    
    if section_id:
        pages = await repo.get_by_section_id(section_id, include_deleted=False)
    else:
        pages = []
    
    return [PageResponse(
        id=page.id,
        section_id=page.section_id,
        parent_page_id=page.parent_page_id,
        title=page.title,
        content=page.content,
        content_plain=page.content_plain,
        display_order=page.display_order,
        created_at=page.created_at,
        updated_at=page.updated_at,
        deleted_at=page.deleted_at
    ) for page in pages]


@router.post("/", response_model=PageResponse, status_code=status.HTTP_201_CREATED)
async def create_page(
    page_data: PageCreate,
    db: AsyncSession = Depends(get_db),
):
    """
    Create a new page in a section.
    
    Returns:
        Created page with ID.
    """
    repo = get_page_repository(db)
    
    # Extract plain text for search
    content_plain = extract_plain_text(page_data.content)
    
    # Create domain entity
    page = Page(
        id="",  # Will be generated by repository
        section_id=page_data.section_id,
        title=page_data.title.strip(),
        content=page_data.content,
        content_plain=content_plain,
        parent_page_id=page_data.parent_page_id,
        display_order=page_data.display_order,
    )
    
    # Validate
    is_valid, error_msg = page.validate()
    if not is_valid:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=error_msg)
    
    # Save
    created_page = await repo.create(page)
    
    return PageResponse(
        id=created_page.id,
        section_id=created_page.section_id,
        parent_page_id=created_page.parent_page_id,
        title=created_page.title,
        content=created_page.content,
        content_plain=created_page.content_plain,
        display_order=created_page.display_order,
        created_at=created_page.created_at,
        updated_at=created_page.updated_at,
        deleted_at=created_page.deleted_at
    )


@router.get("/{page_id}", response_model=PageResponse)
async def get_page(
    page_id: str,
    db: AsyncSession = Depends(get_db),
):
    """
    Get page by ID.
    
    Args:
        page_id: UUID of the page.
    
    Returns:
        Page details with content.
    """
    repo = get_page_repository(db)
    page = await repo.get_by_id(page_id)
    
    if not page:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Page not found")
    
    return PageResponse(
        id=page.id,
        section_id=page.section_id,
        parent_page_id=page.parent_page_id,
        title=page.title,
        content=page.content,
        content_plain=page.content_plain,
        display_order=page.display_order,
        created_at=page.created_at,
        updated_at=page.updated_at,
        deleted_at=page.deleted_at
    )


@router.put("/{page_id}", response_model=PageResponse)
async def update_page(
    page_id: str,
    page_data: PageUpdate,
    db: AsyncSession = Depends(get_db),
):
    """
    Update page content and metadata.
    
    Args:
        page_id: UUID of the page.
    
    Returns:
        Updated page.
    """
    repo = get_page_repository(db)
    page = await repo.get_by_id(page_id)
    
    if not page:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Page not found")
    
    # Update fields
    if page_data.title is not None:
        page.title = page_data.title.strip()
    if page_data.content is not None:
        page.content = page_data.content
        page.content_plain = extract_plain_text(page_data.content)
    if page_data.display_order is not None:
        page.display_order = page_data.display_order
    
    # Validate
    is_valid, error_msg = page.validate()
    if not is_valid:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=error_msg)
    
    # Save
    updated_page = await repo.update(page)
    
    return PageResponse(
        id=updated_page.id,
        section_id=updated_page.section_id,
        parent_page_id=updated_page.parent_page_id,
        title=updated_page.title,
        content=updated_page.content,
        content_plain=updated_page.content_plain,
        display_order=updated_page.display_order,
        created_at=updated_page.created_at,
        updated_at=updated_page.updated_at,
        deleted_at=updated_page.deleted_at
    )


@router.delete("/{page_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_page(
    page_id: str,
    db: AsyncSession = Depends(get_db),
):
    """
    Soft delete a page.
    
    Args:
        page_id: UUID of the page.
    
    Returns:
        Success confirmation.
    """
    repo = get_page_repository(db)
    success = await repo.delete(page_id)
    
    if not success:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Page not found")
    
    return None


@router.post("/{page_id}/autosave", response_model=PageResponse)
async def autosave_page(
    page_id: str,
    page_data: PageUpdate,
    db: AsyncSession = Depends(get_db),
):
    """
    Auto-save page content (debounced updates).
    
    Args:
        page_id: UUID of the page.
    
    Returns:
        Success confirmation with timestamp.
    """
    # For now, this is the same as update
    return await update_page(page_id, page_data, db)

