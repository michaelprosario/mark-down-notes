"""API router for section operations."""

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from typing import List, Optional

from src.api.dependencies import get_db, get_section_repository
from src.api.schemas import SectionCreate, SectionUpdate, SectionResponse
from src.core.domain.section import Section

router = APIRouter(
    prefix="/api/sections",
    tags=["sections"],
)


@router.get("/", response_model=List[SectionResponse])
async def list_sections(
    notebook_id: Optional[str] = None,
    db: AsyncSession = Depends(get_db),
):
    """
    List sections, optionally filtered by notebook.
    
    Args:
        notebook_id: Optional notebook UUID to filter by.
    
    Returns:
        List of sections.
    """
    repo = get_section_repository(db)
    
    if notebook_id:
        sections = await repo.get_by_notebook_id(notebook_id, include_deleted=False)
    else:
        # For now, return empty if no notebook specified
        sections = []
    
    return [SectionResponse(
        id=sec.id,
        notebook_id=sec.notebook_id,
        name=sec.name,
        display_order=sec.display_order,
        created_at=sec.created_at,
        updated_at=sec.updated_at,
        deleted_at=sec.deleted_at
    ) for sec in sections]


@router.post("/", response_model=SectionResponse, status_code=status.HTTP_201_CREATED)
async def create_section(
    section_data: SectionCreate,
    db: AsyncSession = Depends(get_db),
):
    """
    Create a new section in a notebook.
    
    Returns:
        Created section with ID.
    """
    repo = get_section_repository(db)
    
    # Create domain entity
    section = Section(
        id="",  # Will be generated by repository
        notebook_id=section_data.notebook_id,
        name=section_data.name.strip(),
        display_order=section_data.display_order,
    )
    
    # Validate
    is_valid, error_msg = section.validate()
    if not is_valid:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=error_msg)
    
    # Save
    created_section = await repo.create(section)
    
    return SectionResponse(
        id=created_section.id,
        notebook_id=created_section.notebook_id,
        name=created_section.name,
        display_order=created_section.display_order,
        created_at=created_section.created_at,
        updated_at=created_section.updated_at,
        deleted_at=created_section.deleted_at
    )


@router.get("/{section_id}", response_model=SectionResponse)
async def get_section(
    section_id: str,
    db: AsyncSession = Depends(get_db),
):
    """
    Get section by ID.
    
    Args:
        section_id: UUID of the section.
    
    Returns:
        Section details with pages.
    """
    repo = get_section_repository(db)
    section = await repo.get_by_id(section_id)
    
    if not section:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Section not found")
    
    return SectionResponse(
        id=section.id,
        notebook_id=section.notebook_id,
        name=section.name,
        display_order=section.display_order,
        created_at=section.created_at,
        updated_at=section.updated_at,
        deleted_at=section.deleted_at
    )


@router.put("/{section_id}", response_model=SectionResponse)
async def update_section(
    section_id: str,
    section_data: SectionUpdate,
    db: AsyncSession = Depends(get_db),
):
    """
    Update section details.
    
    Args:
        section_id: UUID of the section.
    
    Returns:
        Updated section.
    """
    repo = get_section_repository(db)
    section = await repo.get_by_id(section_id)
    
    if not section:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Section not found")
    
    # Update fields
    if section_data.name is not None:
        section.name = section_data.name.strip()
    if section_data.display_order is not None:
        section.display_order = section_data.display_order
    
    # Validate
    is_valid, error_msg = section.validate()
    if not is_valid:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=error_msg)
    
    # Save
    updated_section = await repo.update(section)
    
    return SectionResponse(
        id=updated_section.id,
        notebook_id=updated_section.notebook_id,
        name=updated_section.name,
        display_order=updated_section.display_order,
        created_at=updated_section.created_at,
        updated_at=updated_section.updated_at,
        deleted_at=updated_section.deleted_at
    )


@router.delete("/{section_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_section(
    section_id: str,
    db: AsyncSession = Depends(get_db),
):
    """
    Soft delete a section.
    
    Args:
        section_id: UUID of the section.
    
    Returns:
        Success confirmation.
    """
    repo = get_section_repository(db)
    success = await repo.delete(section_id)
    
    if not success:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Section not found")
    
    return None


@router.put("/{section_id}/reorder", response_model=SectionResponse)
async def reorder_section(
    section_id: str,
    new_order: int,
    db: AsyncSession = Depends(get_db),
):
    """
    Update section display order.
    
    Args:
        section_id: UUID of the section.
        new_order: New display order value.
    
    Returns:
        Updated section with new order.
    """
    repo = get_section_repository(db)
    
    try:
        updated_section = await repo.reorder(section_id, new_order)
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    
    return SectionResponse(
        id=updated_section.id,
        notebook_id=updated_section.notebook_id,
        name=updated_section.name,
        display_order=updated_section.display_order,
        created_at=updated_section.created_at,
        updated_at=updated_section.updated_at,
        deleted_at=updated_section.deleted_at
    )

